name: DNS TLS Certificate Validation

on:
  workflow_dispatch:
    inputs:
      letsencrypt_demo:
        description: 'DEMO instance Letsencrypt TLS cert request'
        required: true
        default: true
        type: boolean
      letsencrypt_monitoring:
        description: 'MONITORING instance Letsencrypt TLS cert request'
        required: true
        default: false
        type: boolean
      letsencrypt_frontend:
        description: 'FRONTEND instance Letsencrypt TLS cert request'
        required: true
        default: false
        type: boolean
      letsencrypt_backend:
        description: 'BACKEND instance Letsencrypt TLS cert request'
        required: true
        default: false
        type: boolean

jobs:
  fetch-and-validate-tls-certs:
    runs-on: ubuntu-latest

    permissions:
      id-token: write # for aws OIDC STS tokens to work
      contents: read
      actions: read

    steps:

    - name: Checkout SCM
      uses: actions/checkout@v5
      # https://github.com/actions/checkout

    - name: Configure AWS Credentials with OIDC JWT Token for STS Access to Hcloud Backend Role
      uses: aws-actions/configure-aws-credentials@v5.1.1
      # https://github.com/aws-actions/configure-aws-credentials
      with:
        role-to-assume: arn:aws:iam::010928217051:role/OpenID_Connect_GithubActions_TerraformHcloudBackendAccess
        role-session-name: DeployHcloudIAMAccess_STSSession
        aws-region: ${{ vars.AWS_REGION }}

    - name: Query SSH private keys for Hcloud servers from AWS Secrets Manager
      env:
        MASTER_PRIVATE_KEY: fiscalismia-infrastructure-master-key-hcloud
        LOADBALANCER_PRIVATE_KEY: fiscalismia-loadbalancer-instance-key-hcloud
        NAT_GATEWAY_PRIVATE_KEY: fiscalismia-nat-gateway-instance-key-hcloud
        MONITORING_PRIVATE_KEY: fiscalismia-monitoring-instance-key-hcloud
        DEMO_PRIVATE_KEY: fiscalismia-demo-instance-key-hcloud
        PRODUCTION_PRIVATE_KEY: fiscalismia-production-instances-key-hcloud
      run: |
        set -eou pipefail
        mkdir -p ~/.ssh/

        echo "Starting ssh-agent and exporting environment variables"
        eval "$(ssh-agent -s)"
        echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
        echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV

        query_aws_plaintext_secret() {
          echo "Querying $1 from AWS"
          aws secretsmanager get-secret-value \
            --secret-id $1 \
            --output text \
            --query SecretString \
            | ssh-add - > /dev/null 2>&1
        }

        query_aws_plaintext_secret ${MASTER_PRIVATE_KEY}
        query_aws_plaintext_secret ${LOADBALANCER_PRIVATE_KEY}
        query_aws_plaintext_secret ${NAT_GATEWAY_PRIVATE_KEY}
        query_aws_plaintext_secret ${MONITORING_PRIVATE_KEY}
        query_aws_plaintext_secret ${DEMO_PRIVATE_KEY}
        query_aws_plaintext_secret ${PRODUCTION_PRIVATE_KEY}

    - name: Extract Hcloud Server IP Adresses from Remote State
      env:
        S3_BUCKET: hangrybear-tf-backend-state-bucket
        S3_PREFIX: fiscalismia-infrastructure/hcloud
        S3_KEY: state.tfstate
      run : |
        aws s3 cp s3://${S3_BUCKET}/${S3_PREFIX}/${S3_KEY} .

        bastion_ip=$(cat state.tfstate | jq -r .outputs.fiscalismia_bastion_host_ipv4.value )
        demo_ip=$(cat state.tfstate | jq -r .outputs.fiscalismia_demo_private_ipv4.value )
        lb_ip=$(cat state.tfstate | jq -r .outputs.fiscalismia_loadbalancer_private_ipv4.value )
        nat_ip=$(cat state.tfstate | jq -r .outputs.fiscalismia_nat_gateway_private_ipv4.value )
        monitor_ip=$(cat state.tfstate | jq -r .outputs.fiscalismia_monitoring_private_ipv4.value )
        front_ip=$(cat state.tfstate | jq -r .outputs.fiscalismia_frontend_private_ipv4.value )
        back_ip=$(cat state.tfstate | jq -r .outputs.fiscalismia_backend_private_ipv4.value )
        sentinel_ip=$(cat state.tfstate | jq -r .outputs.network_sentinel_private_ipv4.value )

        echo "BASTION_HOST_PUBLIC_IP=$bastion_ip" >> $GITHUB_ENV
        echo "DEMO_INSTANCE_PRIVATE_IP=$demo_ip" >> $GITHUB_ENV
        echo "LOADBALANCER_PRIVATE_IP=$lb_ip" >> $GITHUB_ENV
        echo "NAT_GATEWAY_PRIVATE_IP=$nat_ip" >> $GITHUB_ENV
        echo "MONITORING_INSTANCE_PRIVATE_IP=$monitor_ip" >> $GITHUB_ENV
        echo "FRONTEND_INSTANCE_PRIVATE_IP=$front_ip" >> $GITHUB_ENV
        echo "BACKEND_INSTANCE_PRIVATE_IP=$back_ip" >> $GITHUB_ENV
        echo "NETWORK_SENTINEL_PRIVATE_IP=$sentinel_ip" >> $GITHUB_ENV

    - name: Create SSH Config for Bastion-Host ProxyJump
      run: |
        cat << EOF > ~/.ssh/config
        Host bastion-host
            HostName $BASTION_HOST_PUBLIC_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null

        Host demo
            HostName $DEMO_INSTANCE_PRIVATE_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ProxyJump bastion-host

        Host loadbalancer
            HostName $LOADBALANCER_PRIVATE_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ProxyJump bastion-host

        Host nat-gateway
            HostName $NAT_GATEWAY_PRIVATE_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ProxyJump bastion-host

        Host network-sentinel
            HostName $NETWORK_SENTINEL_PRIVATE_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ProxyJump bastion-host

        Host monitoring
            HostName $MONITORING_INSTANCE_PRIVATE_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ProxyJump bastion-host

        Host frontend
            HostName $FRONTEND_INSTANCE_PRIVATE_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ProxyJump bastion-host

        Host backend
            HostName $BACKEND_INSTANCE_PRIVATE_IP
            User root
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ProxyJump bastion-host
        EOF

        chmod 600 ~/.ssh/config

    - name: Copy AWS Credentials to Target Instances
      env:
        CREDENTIALS: /tmp/.aws/credentials
        REMOTE_DIR: /root/.aws
        S3_BUCKET: hangrybear-tf-backend-state-bucket
        S3_PREFIX: fiscalismia-infrastructure/aws
        S3_KEY: state.tfstate
      run: |
        aws s3 cp s3://${S3_BUCKET}/${S3_PREFIX}/${S3_KEY} .

        mkdir -p /tmp/.aws/
        cat << EOF > ${CREDENTIALS}
        [default]
        aws_access_key_id = $(cat state.tfstate | jq -r .outputs.hcloud_dns_renewal_access_key.value)
        aws_secret_access_key = $(cat state.tfstate | jq -r .outputs.hcloud_dns_renewal_secret_key.value)
        region = eu-central-1
        EOF

        chmod 600 ${CREDENTIALS}

        aws_cmd="aws sts get-caller-identity"

        ssh demo "mkdir -p $REMOTE_DIR"
        ssh frontend "mkdir -p $REMOTE_DIR"
        ssh backend "mkdir -p $REMOTE_DIR"
        ssh monitoring "mkdir -p $REMOTE_DIR"

        scp ${CREDENTIALS} demo:${REMOTE_DIR}/credentials
        scp ${CREDENTIALS} frontend:${REMOTE_DIR}/credentials
        scp ${CREDENTIALS} backend:${REMOTE_DIR}/credentials
        scp ${CREDENTIALS} monitoring:${REMOTE_DIR}/credentials

        ssh demo $aws_cmd
        ssh frontend $aws_cmd
        ssh backend $aws_cmd
        ssh monitoring $aws_cmd

        rm -f ${S3_KEY}
        rm -f ${CREDENTIALS}

    - name: DEMO instance certbot TLS request & DNS validation script
      if: inputs.letsencrypt_demo == true
      env:
        DEMO_DOMAIN: demo.fiscalismia.com
        DEMO_BACKEND_DOMAIN: backend.demo.fiscalismia.com
        DEMO_FASTAPI_DOMAIN: fastapi.demo.fiscalismia.com
        REMOTE_LOG: /root/certbot_dns_validation.log
        SCRIPT_PATH: /root/scripts/fetch-and-validate-tls-certificates.sh
      run: |
        ssh demo "nohup $SCRIPT_PATH $DEMO_DOMAIN $DEMO_BACKEND_DOMAIN $DEMO_FASTAPI_DOMAIN > $REMOTE_LOG 2>&1 &"

    - name: MONITORING instance certbot TLS request & DNS validation script
      if: inputs.letsencrypt_monitoring == true
      env:
        MONITORING_DOMAIN: monitoring.fiscalismia.com
        REMOTE_LOG: /root/certbot_dns_validation.log
        SCRIPT_PATH: /root/scripts/fetch-and-validate-tls-certificates.sh
      run: |
        ssh monitoring "nohup $SCRIPT_PATH $MONITORING_DOMAIN > $REMOTE_LOG 2>&1 &"

    - name: FRONTEND instance certbot TLS request & DNS validation script
      if: inputs.letsencrypt_frontend == true
      env:
        FRONTEND_DOMAIN: fiscalismia.com
        REMOTE_LOG: /root/certbot_dns_validation.log
        SCRIPT_PATH: /root/scripts/fetch-and-validate-tls-certificates.sh
      run: |
        ssh frontend "nohup $SCRIPT_PATH $FRONTEND_DOMAIN > $REMOTE_LOG 2>&1 &"

    - name: BACKEND instance certbot TLS request & DNS validation script
      if: inputs.letsencrypt_backend == true
      env:
        BACKEND_DOMAIN: backend.fiscalismia.com
        FASTAPI_DOMAIN: fastapi.fiscalismia.com
        REMOTE_LOG: /root/certbot_dns_validation.log
        SCRIPT_PATH: /root/scripts/fetch-and-validate-tls-certificates.sh
      run: |
        ssh backend "nohup $SCRIPT_PATH $BACKEND_DOMAIN $FASTAPI_DOMAIN > $REMOTE_LOG 2>&1 &"