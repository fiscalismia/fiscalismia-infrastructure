## Debugging Port Mapping Issue

If HAProxy is external and hitting `host-ip:443`, port mapping `443:443` should work. Let's diagnose:

**Step 1: Verify port is listening on host**

```bash
# On the demo instance
ss -tlnp | grep 443
# or
netstat -tlnp | grep 443
```

**Step 2: Check Docker port mapping**

```bash
docker ps --format "table {{.Names}}\t{{.Ports}}"
# Should show: 0.0.0.0:443->443/tcp
```

**Step 3: Test locally on the instance**

```bash
# From the demo instance itself
curl -k https://localhost:443 -v
```

**Step 4: Check firewall**

```bash
# Check if firewall allows 443
sudo iptables -L -n | grep 443
# or on firewalld systems
sudo firewall-cmd --list-ports
```

## Common Causes

| Issue | Check | Fix |
|-------|-------|-----|
| Port bound to 127.0.0.1 only | `ss -tlnp` shows `127.0.0.1:443` | Use `ports: "0.0.0.0:443:443"` |
| Firewall blocking | `iptables -L` | `sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT` |
| Docker iptables disabled | `dockerd` config | Enable iptables in Docker daemon |
| SELinux blocking | `ausearch -m avc` | Check SELinux denials |
| Container not actually listening | `docker logs` | Check nginx started correctly |

**Step 5: Check if nginx is actually listening inside container**

```bash
docker exec fiscalismia-frontend ss -tlnp
# Should show nginx listening on 443
```

What does `ss -tlnp | grep 443` show on your demo instance when using port mapping?


debug log:

[root@Fiscalismia-Demo ~]# podman ps
CONTAINER ID  IMAGE                                                 COMMAND               CREATED         STATUS                   PORTS                           NAMES
6f59cb2b77f9  docker.io/library/fiscalismia-postgres:1.0.0          -p 5432               22 minutes ago  Up 17 seconds (healthy)  5432/tcp                        fiscalismia-postgres
4743724fa4ed  ghcr.io/fiscalismia/fiscalismia-frontend-demo:latest  nginx -g daemon o...  2 minutes ago   Up 17 seconds            0.0.0.0:443->443/tcp, 8080/tcp  fiscalismia-frontend
[root@Fiscalismia-Demo ~]# podman exec -it fiscalismia-frontend sh
/etc/nginx $ netstat -ltnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      1/nginx: master pro
/etc/nginx $ 

[root@Fiscalismia-Demo ~]# nft list ruleset
table ip lockdown_private_instances {
	chain input {
		type filter hook input priority filter; policy drop;
		iif "lo" accept
		ct state established,related accept
		ip saddr 172.20.1.2 tcp dport 22 ct state new accept
		ip saddr 172.20.1.3 tcp dport { 80, 443, 8443 } ct state new accept
		ip saddr 172.20.1.3 icmp type echo-request accept
	}

	chain output {
		type filter hook output priority filter; policy drop;
		oif "lo" accept
		ct state established,related accept
		ip daddr { 8.8.8.8, 185.12.64.1, 185.12.64.2 } udp dport 53 ct state new accept
		icmp type echo-request accept
		tcp dport { 80, 443 } ct state new accept
	}

	chain forward {
		type filter hook forward priority filter; policy drop;
	}
}



loadbalancer ingress remote:
[root@Fiscalismia-LoadBalancer ~]# curl -k 172.20.0.2:443 -v
*   Trying 172.20.0.2:443...
Timeout

[root@Fiscalismia-LoadBalancer ~]# nc -v4z 172.20.0.2 443
Ncat: Version 7.92 ( https://nmap.org/ncat )
Ncat: TIMEOUT


But when I switch to network_mode:host it works, see the debug log:
[root@Fiscalismia-Demo ~]# podman ps
CONTAINER ID  IMAGE                                                 COMMAND               CREATED         STATUS                   PORTS              NAMES
6f59cb2b77f9  docker.io/library/fiscalismia-postgres:1.0.0          -p 5432               28 minutes ago  Up 4 seconds (starting)  5432/tcp           fiscalismia-postgres
90f877aa4d63  ghcr.io/fiscalismia/fiscalismia-frontend-demo:latest  nginx -g daemon o...  4 seconds ago   Up 4 seconds             443/tcp, 8080/tcp  fiscalismia-frontend
[root@Fiscalismia-Demo ~]# podman exec -it fiscalismia-frontend sh
/etc/nginx $ netstat -ltnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      1/nginx: master pro
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -
tcp        0      0 127.0.0.54:53           0.0.0.0:*               LISTEN      -
tcp        0      0 0.0.0.0:5355            0.0.0.0:*               LISTEN      -
tcp        0      0 10.89.1.1:53            0.0.0.0:*               LISTEN      -
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -
tcp        0      0 :::22                   :::*                    LISTEN      -
tcp        0      0 :::5355                 :::*                    LISTEN      -
/etc/nginx $ 

[root@Fiscalismia-LoadBalancer ~]# nc -v4z 172.20.0.2 443
Ncat: Version 7.92 ( https://nmap.org/ncat )
Ncat: Connected to 172.20.0.2:443.
Ncat: 0 bytes sent, 0 bytes received in 0.03 seconds.


[root@Fiscalismia-LoadBalancer ~]# curl -k 172.20.0.2:443 -v
*   Trying 172.20.0.2:443...
* Connected to 172.20.0.2 (172.20.0.2) port 443
* using HTTP/1.x
> GET / HTTP/1.1
> Host: 172.20.0.2:443
> User-Agent: curl/8.11.1
> Accept: */*
>
* Request completely sent off
* Recv failure: Connection reset by peer
* closing connection #0
curl: (56) Recv failure: Connection reset by peer

######################################
######################################
######################################
######################################
######################################

## Solution: Allow Podman Bridge Traffic in nftables

You need to allow forwarding for the Podman network interface while keeping your security posture tight.

### Step 1: Find Podman Network Interface Name

```bash
# On the demo instance
podman network inspect fiscalismia-network | grep -i bridge
# Or
ip link show | grep -E "podman|cni"
```

Podman typically creates interfaces like `podman0`, `podman1`, or `cni-podman0`.

### Step 2: Update nftables Script

````bash
#!/usr/bin/env bash

################################ INFO ########################################################################################
# This file is intended for private instances without a public ip assigned, to which hcloud does not allow attaching firewalls
# We manually install and configure nftables, the best practice tools for firewall rules used as backend for other frameworks
# PARAM $1 is the loadbalancer private ipv4 for https ingress allowance
# PARAM $2 is the bastion-host private ipv4 for ssh ingress allowance
# PARAM $3 is the nat-gateway private ipv4 for https and http egress allowance
# PARAM $4 is the virtual network gateway used as the next-hop target for private egress to NAT-Gateway
# PARAM $5 OPTIONAL Parameter to allow an additional port for ingress on the demo instance running frontend + backend
# e.g. ./scripts/nftables_lockdown_private_instances.sh 172.20.1.3 172.20.1.2 172.20.1.4 172.20.0.1
##############################################################################################################################

# wait for the private network interface to initialize.
sleep 60

export LOADBALANCER_PRIVATE_IP="$1"
export BASTION_HOST_PRIVATE_IP="$2"
export NAT_GATEWAY_PRIVATE_IP="$3"
export VIRTUAL_NETWORK_GATEWAY="$4"
export TABLE_NAME='lockdown_private_instances'
export CONFIG_PATH='/etc/sysconfig/nftables.conf'

# Podman default network subnet (check with: podman network inspect podman)
export PODMAN_NETWORK_SUBNET="10.89.0.0/16"

if [[ -z "$1" ]] || [[ -z "$2" ]] || [[ -z "$3" ]] || [[ -z "$4" ]]; then
    echo "Error: Missing required parameters."
    echo "Usage: $0 <LOADBALANCER_PRIVATE_IP> <BASTION_HOST_PRIVATE_IP> <NAT_GATEWAY_PRIVATE_IP> <VIRTUAL_NETWORK_GATEWAY>"
    exit 1
fi

if [[ "$5" ]]; then
    echo "Allowing additional port for demo instance: $5"
    export LB_INGRESS_PORTS="{80,443,$5}"
else
    export LB_INGRESS_PORTS="{80,443}"
fi

### INSTALLATION ###
sudo dnf install --quiet -y nftables
printf "\n# network filter tables installed binary path:\n"
which nft

### CONFIGURATION ###

cat << EOF > $CONFIG_PATH
#!/usr/sbin/nft -f

# Delete previous table
table ip $TABLE_NAME
delete table ip $TABLE_NAME

# Create new IPv4 table
table ip $TABLE_NAME {

    # Filter ingress traffic
    chain input {

        # Drop all ingress for all protocols by default unless explicitly allowed
        type filter hook input priority 0; policy drop;

        # Allow loopback to localhost for internal services
        iif lo accept

        # Allow established and related connections
        ct state established,related accept

        # Allow SSH Ingress from Bastion Host
        ip saddr $BASTION_HOST_PRIVATE_IP tcp dport 22 ct state new accept

        # Allow HTTPS Ingress from Loadbalancer
        ip saddr $LOADBALANCER_PRIVATE_IP tcp dport $LB_INGRESS_PORTS ct state new accept

        # Allow ICMP Ping Ingress from Loadbalancer
        ip saddr $LOADBALANCER_PRIVATE_IP icmp type echo-request accept

        # Allow Podman container traffic to host (for port-mapped services)
        ip saddr $PODMAN_NETWORK_SUBNET accept
    }

    # Allow outbound http, https, dns, icmp
    chain output {
        # Drop all egress by default unless explicitly allowed
        type filter hook output priority 0; policy drop;

        # Allow Loopback
        oif lo accept

        # Allow established and related connections
        ct state established,related accept

        # Allow DNS queries to Hetzner DNS Servers and the Fallback DNS Server
        ip daddr {185.12.64.2, 185.12.64.1, 8.8.8.8} udp dport 53 ct state new accept

        # Allow ICMP to internet
        icmp type echo-request accept

        # Allow HTTP, HTTPS to internet
        tcp dport {80,443} ct state new accept

        # Allow traffic to Podman containers
        ip daddr $PODMAN_NETWORK_SUBNET accept
    }

    # Allow Podman container-to-container and port-forwarding traffic
    chain forward {
        type filter hook forward priority 0; policy drop;

        # Allow established and related connections
        ct state established,related accept

        # Allow traffic between Podman containers (same network)
        ip saddr $PODMAN_NETWORK_SUBNET ip daddr $PODMAN_NETWORK_SUBNET accept

        # Allow incoming traffic to be forwarded to containers (port mapping)
        ip daddr $PODMAN_NETWORK_SUBNET ct state new accept

        # Allow container responses back out
        ip saddr $PODMAN_NETWORK_SUBNET ct state new accept
    }
}
EOF

# ...existing code...
````

### More Restrictive Alternative (Interface-Based)

If you want tighter control using interface names instead of subnets:

````bash
# ...existing code...

cat << EOF > $CONFIG_PATH
#!/usr/sbin/nft -f

table ip $TABLE_NAME
delete table ip $TABLE_NAME

table ip $TABLE_NAME {

    chain input {
        type filter hook input priority 0; policy drop;

        iif lo accept
        ct state established,related accept

        ip saddr $BASTION_HOST_PRIVATE_IP tcp dport 22 ct state new accept
        ip saddr $LOADBALANCER_PRIVATE_IP tcp dport $LB_INGRESS_PORTS ct state new accept
        ip saddr $LOADBALANCER_PRIVATE_IP icmp type echo-request accept

        # Allow traffic from any podman interface
        iifname "podman*" accept
    }

    chain output {
        type filter hook output priority 0; policy drop;

        oif lo accept
        ct state established,related accept

        ip daddr {185.12.64.2, 185.12.64.1, 8.8.8.8} udp dport 53 ct state new accept
        icmp type echo-request accept
        tcp dport {80,443} ct state new accept

        # Allow traffic to any podman interface
        oifname "podman*" accept
    }

    chain forward {
        type filter hook forward priority 0; policy drop;

        ct state established,related accept

        # Allow forwarding between podman interfaces (container-to-container)
        iifname "podman*" oifname "podman*" accept

        # Allow external traffic to be forwarded to containers (port mapping ingress)
        oifname "podman*" ct state new accept

        # Allow container traffic to be forwarded out (container responses)
        iifname "podman*" ct state new accept
    }
}
EOF

# ...existing code...
````

## Summary of Changes

| Chain | Rule Added | Purpose |
|-------|------------|---------|
| `input` | `iifname "podman*" accept` | Allow container → host traffic |
| `output` | `oifname "podman*" accept` | Allow host → container traffic |
| `forward` | `iifname "podman*" oifname "podman*" accept` | Container-to-container (backend ↔ postgres) |
| `forward` | `oifname "podman*" ct state new accept` | External ingress via port mapping |
| `forward` | `iifname "podman*" ct state new accept` | Container response traffic |

This allows:
- ✅ Backend → PostgreSQL communication via `fiscalismia-network`
- ✅ External loadbalancer → Frontend via port mapping (if you switch from `network_mode: host`)
- ✅ External loadbalancer → Backend:8443 via port mapping
- ❌ Containers cannot reach arbitrary external hosts (still locked down)